#include "graphichandler.h"

#include "NontetrisConfig.h"

#ifdef __DUETTO__
#include "duettogl.h"
#include <duetto/client.h>
#include <duetto/clientlib.h>
#elif defined(EMSCRIPTEN)
#include <GL/glfw.h>
#else
#include <GL/glew.h>
#include <GL/glfw.h>
#endif

#include <algorithm>
#include <cmath>
#ifndef __DUETTO__
#include <fstream>
#include <iostream>
#include "SOIL/SOIL.h"
#endif
#include <string>

#include "NontetrisConfig.h"



#ifdef __DUETTO__
typedef GLsizei glvapt;
#else
typedef void * glvapt;
#endif

void printLog(GLuint obj, const std::string & str)
{
#ifndef __DUETTO__
	int infologLength = 0;
	char infoLog[1024];

	if (glIsShader(obj))
		glGetShaderInfoLog(obj, 1024, &infologLength, infoLog);
	else
		glGetProgramInfoLog(obj, 1024, &infologLength, infoLog);

	if (infologLength > 0)
		std::cout << str <<infoLog << std::endl;
#endif
}
void ortho(GLfloat * out, double left, double right, double bottom, double top, double near, double far)
{
	//COPIED FROM javascript gl-matrix
	double lr = 1 / (left - right),
	       bt = 1 / (bottom - top),
	       nf = 1 / (near - far);
	out[0] = -2 * lr;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = -2 * bt;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 2 * nf;
	out[11] = 0;
	out[12] = (left + right) * lr;
	out[13] = (top + bottom) * bt;
	out[14] = (far + near) * nf;
	out[15] = 1;
}


void perspective (GLfloat * out, double fovy, double aspect, double near, double far)
{
	//COPIED FROM javascript gl-matrix
	//double f = 1.0 / tan(fovy / 2),
	double f = 1.0 / 0.4142135623730950488016887242097,
	    nf = 1 / (near - far);

	out[0] = f / aspect;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = f;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = (far + near) * nf;
	out[11] = -1;
	out[12] = 0;
	out[13] = 0;
	out[14] = (2 * far * near) * nf;
	out[15] = 0;
};

void eye(GLfloat * out)
{
	out[0] = 1;
	out[1] = 0;
	out[2] = 0;
	out[3] = 0;
	out[4] = 0;
	out[5] = 1;
	out[6] = 0;
	out[7] = 0;
	out[8] = 0;
	out[9] = 0;
	out[10] = 1;
	out[11] = 0;
	out[12] = 0;
	out[13] = 0;
	out[14] = 0;
	out[15] = 1;
}

void translate (GLfloat * out, GLfloat * v) {
	double x = v[0], y = v[1], z = v[2];

	out[12] = out[0] * x + out[4] * y + out[8] * z + out[12];
	out[13] = out[1] * x + out[5] * y + out[9] * z + out[13];
	out[14] = out[2] * x + out[6] * y + out[10] * z + out[14];
	out[15] = out[3] * x + out[7] * y + out[11] * z + out[15];
};

GraphicHandler::GraphicHandler(int width, int height, bool fullscreen):width(width), height(height)
{
	#ifndef __DUETTO__
	glfwInit();
	glfwOpenWindowHint(GLFW_FSAA_SAMPLES,8);
	glfwOpenWindow(width, height, 5, 6, 5, 8, 0, 0, fullscreen?GLFW_FULLSCREEN:GLFW_WINDOW );

	#if !defined(EMSCRIPTEN) && !defined(__DUETTO__)
	if(glewInit() != GLEW_OK)
		std::cerr<<"GLEW fail"<<std::endl;
	#endif
	#else //defined(__DUETTO__)
	duettoGLInit(width, height);
	#endif

	GLuint vs, fs;
	sp = glCreateProgram();
	vs = glCreateShader(GL_VERTEX_SHADER);
	const char * vss[1] = {"attribute vec3 aVertexPosition;"

			"uniform mat4 uMVMatrix;"
			"uniform mat4 uPMatrix;"

			"void main(void) {"
			"gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);"
			"}"};
	glShaderSource(vs, 1, vss, NULL); //TODO: NULL should not work on PC
			
			
	glCompileShader(vs);
	fs = glCreateShader(GL_FRAGMENT_SHADER);
	const char * fss[1] = {"precision mediump float;"

			"void main(void) {"
			"gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);"
			"}"};
	glShaderSource(fs, 1, fss, NULL);
			
	glCompileShader(fs);
	glAttachShader(sp, vs);
	glAttachShader(sp, fs);
	glLinkProgram(sp);

	glUseProgram(sp);
	aVertexPositionLoc = glGetAttribLocation(sp, "aVertexPosition");
	glEnableVertexAttribArray(aVertexPositionLoc);
	uRTVecLoc = glGetUniformLocation(sp, "uMVMatrix");
	uPMatrixLoc = glGetUniformLocation(sp, "uPMatrix");

	glGenBuffers(1, &vbo_main_rect);
	glBindBuffer(GL_ARRAY_BUFFER_ARB, vbo_main_rect);

	float vert1[9] = { 0.0,  1.0,  0.0,
	        -1.0, -1.0,  0.0,
	         1.0, -1.0,  0.0};

	glBufferData(GL_ARRAY_BUFFER_ARB, 9*sizeof(float), vert1, GL_STATIC_DRAW_ARB);



}

GraphicHandler::~GraphicHandler()
{
	#ifndef __DUETTO__
	glfwTerminate();
	#endif
}

GraphicPiece * GraphicHandler::createpiece(piece<float> pie)
{
	#if 0
	GraphicPiece * pgp = new GraphicPiece;
	GLuint VBOid;
	size_t size = (pie.totsize()+(pie.size()-1))*2;
	std::vector<GLfloat> vertices;
	vertices.reserve(size);
	bool firstshape = true;
	for ( auto pol: pie )
	{
		if ( firstshape )
		{
			firstshape = false;
		}
		else
		{
			vertices.push_back(pol[0].x);
			vertices.push_back(pol[0].y);
		}
		vertices.push_back(pol[0].x);
		vertices.push_back(pol[0].y);
		//std::cerr<<0<<std::endl;

		for ( int i = 1; i <= pol.size()/2; ++i)
		{
			auto & vert = pol[i];

			vertices.push_back(vert.x);
			vertices.push_back(vert.y);
			//std::cerr<<i<<std::endl;
			if(i < (pol.size()+1)/2)
			{
				auto & vert = pol[pol.size()-i];
				//std::cerr<<pol.size()-i<<std::endl;
				vertices.push_back(vert.x);
				vertices.push_back(vert.y);
			}
		}
	}

	glGenBuffers(1, &VBOid);
	glBindBuffer(GL_ARRAY_BUFFER_ARB, VBOid);
	glBufferData(GL_ARRAY_BUFFER_ARB, vertices.size()*sizeof(float), vertices.data(), GL_STATIC_DRAW_ARB);

	pgp->VBOid = VBOid;
	pgp->num = static_cast<int>(size/2);
	pgp->tex = tex[pie.getType()];
	//std::cerr<<"NUM:"<<gp.num<<std::endl;
	return pgp;
	#endif
	return NULL;
}

bool GraphicHandler::render(std::function< void(std::function<void(float x, float y, float rot, GraphicPiece * d)>)>allbodies )
{
	glViewport(0,0,512,512);
	glClearColor(1.0,0.0,1.0,1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	glClear(GL_DEPTH_BUFFER_BIT);

	float pMatrix[16];
	float mVMatrix[16];

	perspective(pMatrix, 0.785, 1, 0.1, 100);
	eye(mVMatrix);
	float trans [3] = {-1.5, 0.0, -7.0};
	translate(mVMatrix, trans);
	glBindBuffer(GL_ARRAY_BUFFER_ARB, vbo_main_rect);
	glVertexAttribPointer(aVertexPositionLoc, 3, GL_FLOAT, false, 0, 0);
	glUniformMatrix4fv(uPMatrixLoc, 16, false, pMatrix);
	glUniformMatrix4fv(uRTVecLoc, 16, false, mVMatrix);
	glDrawArrays(GL_TRIANGLES, 0, 3);

	#ifndef __DUETTO__
	glfwSwapBuffers();
	#endif
	return true;
}
